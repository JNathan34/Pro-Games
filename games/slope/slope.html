<!DOCTYPE html>

<!-- Ultimate Game Stash file--> 
<!-- For the regularly updating doc go to https://docs.google.com/document/d/1_FmH3BlSBQI7FGgAQL59-ZPe8eCxs35wel6JUyVaG8Q/ -->

<html lang="en-us">
  <head>
    <base href="https://cdn.jsdelivr.net/gh/bubbls/UGS-Assets@main/slope%203/">
     <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Slope 3</title>

    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        .webgl-content {
            width: 100% !important;
            height: 100% !important;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #gameContainer {
            width: 100% !important;
            height: 100% !important;
            flex-grow: 1;
        }
        .footer {
            height: 5%;
            width: 100%;
            display: none;
        }
    </style>

    <script>
      window.fileMergerConfig = {
        files: [
          { name: 'Slope3.data.unityweb', parts: 2 } 
        ],
        basePath: '', 
        debug: true
      };
    </script>

    <script>
    (function() {
      'use strict';
      const config = Object.assign({files: [], basePath: '', debug: true}, window.fileMergerConfig || {});
      window.mergedFiles = window.mergedFiles || {};
      const mergeStatus = {};

      function log(...args) { if (config.debug) console.log('[FileMerger]', ...args); }
      function error(...args) { console.error('[FileMerger]', ...args); }
      function normalizeUrl(url) { try { return decodeURIComponent(url.toString().split('?')[0]); } catch (e) { return url; } }
      function urlsMatch(url1, url2) {
        const n1 = normalizeUrl(url1), n2 = normalizeUrl(url2);
        const name1 = n1.split('/').pop().split('?')[0];
        const name2 = n2.split('/').pop().split('?')[0];

        for (const f of config.files) {
            if (name1.startsWith(f.name) && name1.length >= f.name.length) return f.name;
            if (name2.startsWith(f.name) && name2.length >= f.name.length) return f.name;
        }

        return null;
      }

      async function mergeSplitFiles(filePath, partsCount) {
        try {
          const parts = [];
          for (let i = 1; i <= partsCount; i++) parts.push(`${filePath}.part${i}`);
          log(`Merging ${filePath} from ${partsCount} parts...`);
          const responses = await Promise.all(parts.map(p => window.originalFetch(p)));
          for (const r of responses) if (!r.ok) throw new Error(`Part missing: ${r.url} (${r.status})`);
          const buffers = await Promise.all(responses.map(r => r.arrayBuffer()));
          const totalLen = buffers.reduce((acc, b) => acc + b.byteLength, 0);
          const merged = new Uint8Array(totalLen);
          let offset = 0;
          for (const b of buffers) { merged.set(new Uint8Array(b), offset); offset += b.byteLength; }
          log(`✅ Merged: ${filePath} (${(totalLen/1024/1024).toFixed(2)} MB)`);
          return merged.buffer;
        } catch (e) { error(e); throw e; }
      }

      function shouldIntercept(url) {
        const s = normalizeUrl(url);
        if (s.includes('.part')) return null;

        const matchedName = urlsMatch(s, s);
        if (matchedName) return matchedName;
        
        return null;
      }

      function getMerged(name) {
        if (window.mergedFiles[name]) return window.mergedFiles[name];
        for (const [k, v] of Object.entries(window.mergedFiles)) {
             if (k.startsWith(name)) return v;
        }
        return null;
      }

      if (!window.originalFetch) window.originalFetch = window.fetch;
      window.fetch = function(url, ...args) {
        const name = shouldIntercept(url);
        if (name) {
          log('Intercepting fetch:', name);
          return new Promise((resolve, reject) => {
            const t = setInterval(() => {
              const b = getMerged(name);
              if (b) {
                clearInterval(t);
                const type = name.endsWith('.wasm') ? 'application/wasm' : 'application/octet-stream';
                resolve(new Response(b, {status: 200, headers: {'Content-Type': type}}));
              }
              else if (mergeStatus[name] === 'failed') { clearInterval(t); reject(new Error('Merge failed')); }
            }, 50);
          });
        }
        return window.originalFetch.call(this, url, ...args);
      }

      if (!window.OriginalXMLHttpRequest) window.OriginalXMLHttpRequest = window.XMLHttpRequest;
      window.XMLHttpRequest = function(opts) {
        const xhr = new window.OriginalXMLHttpRequest(opts);
        const open = xhr.open;
        xhr.open = function(m, u, ...a) { this._url = u; return open.call(this, m, u, ...a); };
        xhr.send = function(...a) {
          const name = shouldIntercept(this._url);
          if (name) {
            log('Intercepting XHR:', name);
            const t = setInterval(() => {
              const b = getMerged(name);
              if (b) {
                clearInterval(t);
                Object.defineProperties(xhr, { status: {value: 200}, response: {value: b}, readyState: {value: 4} });
                if (xhr.onload) xhr.onload({type: 'load', target: xhr});
              }
            }, 50);
            return;
          }
          return window.OriginalXMLHttpRequest.prototype.send.apply(this, a);
        }
        return xhr;
      }

      async function start() {
        config.files.forEach(f => {
           const path = config.basePath + f.name;
           mergeStatus[f.name] = 'merging';
           mergeSplitFiles(path, f.parts).then(b => {
             window.mergedFiles[f.name] = b; 
             window.mergedFiles[path] = b;
             mergeStatus[f.name] = 'ready';
           }).catch(() => mergeStatus[f.name] = 'failed');
        });
      }
      start();
    })();
    </script>

    <script src="UnityLoader.js"></script>
    <script src="UnityProgress.js"></script>
    
    <script>
        var gameInstance = UnityLoader.instantiate("gameContainer", "build.json", {
            onProgress: UnityProgress,
            Module: {
                onRuntimeInitialized: function() {
                    UnityProgress(gameInstance, "complete")
                }
            }
        });
    </script>
    </head>

<body>

    <div class="webgl-content">
        <div id="gameContainer" style="width: 100%; height: 95%; margin: auto;"></div>
        <div class="footer"></div>

        <script>
            function UnityCallJs() { console.log("unity call!"); }
            function UnityCallPlayJs() { console.log("unity call Play game"); }
            function UnityCallLeaderboardJs() { console.log("unity call On Leaderboard"); }
            function UnityCallAgainJs() { console.log("unity call Again"); }
            function UnityCallEndgameJs() { console.log("unity call end game"); }
            function UnityCallBackHomeJs() { console.log("untiy call backHome"); }
            function UnityCallChangeDayLeaderboardJs() { console.log("untiy call change day leaderboard"); }
            function UnityCallCloseLeaderboardJs() { console.log("untiy call close leaderboard"); }
        </script>

    </div>

<!-- CLOUD SAVE INTEGRATION -->
<script src="https://apis.google.com/js/api.js"></script>
<div id="save-indicator" style="position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.8); color: #fff; padding: 8px 16px; border-radius: 20px; font-family: 'Segoe UI', sans-serif; font-size: 14px; font-weight: 500; display: none; z-index: 9999; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px); box-shadow: 0 4px 6px rgba(0,0,0,0.1);">☁️ Syncing...</div>

<script>
  const CLIENT_ID = '448742201910-98bfqv6ugof15tgdk09mjap1kmgt89lt.apps.googleusercontent.com';
  
  // Initialize Google API
  gapi.load('client', async () => {
      await gapi.client.init({
          discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
      });
      
      // Check for token from home.html
      const token = localStorage.getItem('google_access_token');
      const expiry = localStorage.getItem('token_expiry');
      
      if (token && expiry && Date.now() < parseInt(expiry)) {
          gapi.client.setToken({access_token: token});
          console.log("Game: Cloud Auth Active");
          
          const ind = document.getElementById('save-indicator');
          ind.style.display = 'block';
          ind.innerText = "☁️ Cloud Active";

          // Start auto-save loop (every 60 seconds)
          setInterval(saveToCloud, 60000);
          // Save on exit
          window.addEventListener('beforeunload', saveToCloud);
      }
  });

  async function saveToCloud() {
      const ind = document.getElementById('save-indicator');
      try {
          ind.innerText = "☁️ Syncing...";
          ind.style.display = 'block';
          ind.style.color = '#fff';

          // 1. Prepare Data
          const data = {};
          for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              // Filter out auth tokens to avoid bloating save file
              if(key !== 'google_access_token' && key !== 'user_credential' && key !== 'token_expiry') {
                  data[key] = localStorage.getItem(key);
              }
          }
          const fileContent = JSON.stringify(data);
          const fileMetadata = {
              'name': 'pro_games_save.json',
              'mimeType': 'application/json',
              'parents': ['appDataFolder']
          };

          // 2. Check if file exists
          const response = await gapi.client.drive.files.list({
              spaces: 'appDataFolder',
              q: "name = 'pro_games_save.json'",
              fields: 'files(id)'
          });

          const files = response.result.files;

          if (files && files.length > 0) {
              // Update existing file
              const fileId = files[0].id;
              await gapi.client.request({
                  path: '/upload/drive/v3/files/' + fileId,
                  method: 'PATCH',
                  params: { uploadType: 'media' },
                  body: fileContent
              });
          } else {
              // Create new file
              const form = new FormData();
              form.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' }));
              form.append('file', new Blob([fileContent], { type: 'application/json' }));

              await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                  method: 'POST',
                  headers: new Headers({ 'Authorization': 'Bearer ' + gapi.client.getToken().access_token }),
                  body: form
              });
          }

          // Show indicator
          ind.innerText = "☁️ Saved";
          ind.style.color = '#4caf50';
          setTimeout(() => {
              ind.innerText = "☁️ Cloud Active";
              ind.style.color = '#fff';
          }, 3000);
          console.log("Game saved to cloud.");

      } catch (e) {
          console.error("Cloud Save Error:", e);
          ind.innerText = "⚠️ Sync Failed";
          ind.style.color = '#ff5252';
          setTimeout(() => {
              ind.innerText = "☁️ Cloud Active";
              ind.style.color = '#fff';
          }, 3000);
      }
  }
</script>

</body>
</html>
