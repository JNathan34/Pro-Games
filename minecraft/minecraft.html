<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Minecraft</title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="https://unicons.iconscout.com/release/v4.0.8/css/line.css">
    <title>Minecraft</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; /* Darker background for menu */ }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: transparent; /* Make blocker transparent */
            display: flex; /* Use flex for centering */
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Arial', sans-serif; /* Nicer font */
            text-align: center;
        }
        #menu {
            background-color: rgba(50, 50, 50, 0.85);
            padding: 40px 60px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 500px; /* Optional: constrain menu width */
            pointer-events: auto; /* Make menu interactive */
        }
        #menu h1 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 3em;
            color: #eee;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #menu p {
             margin-bottom: 25px;
             font-size: 1.1em;
             color: #ccc;
        }
        .menu-button {
            display: block;
            width: 200px;
            margin: 15px auto;
            padding: 12px 20px;
            background-color: #5a5a5a;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .menu-button:hover {
            background-color: #777;
        }
         .menu-button:active {
             transform: translateY(1px);
             box-shadow: 0 2px 4px rgba(0,0,0,0.3);
         }
         #settings-content {
             display: none; /* Hidden by default */
             margin-top: 20px;
             padding: 15px;
             background-color: rgba(0,0,0,0.2);
             border-radius: 5px;
             text-align: left; /* Align settings text left */
         }
         #settings-content p {
              font-size: 0.9em;
              margin-bottom: 8px;
         }
         /* New styles for settings elements */
         .setting-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             margin-bottom: 12px;
         }
         .setting-item label {
             margin-right: 15px;
             color: #ddd;
         }
         .setting-item input[type="range"] {
             flex-grow: 1;
             max-width: 200px; /* Limit slider width */
         }
         .setting-item span {
             min-width: 40px; /* Ensure space for value */
             text-align: right;
             color: #eee;
         }

        /* Updated Crosshair Style */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px; /* Thin line */
            height: 10px; /* Vertical line */
            background-color: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none; /* Initially hidden */
            border-radius: 0; /* Remove border-radius */
            border: none; /* Remove border */
        }
        /* Add horizontal part of the crosshair */
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px; /* Horizontal line */
            height: 2px; /* Thin line */
            background-color: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
        }
        /* Add a subtle black outline for contrast */
         #crosshair::after {
             content: '';
             position: absolute;
             top: 50%;
             left: 50%;
             width: 12px; /* Slightly larger outline area */
             height: 12px;
             border: 1px solid rgba(0, 0, 0, 0.5); /* Semi-transparent black border */
             transform: translate(-50%, -50%);
             box-sizing: border-box;
             /* Make the outline only appear around the plus shape */
             clip-path: polygon(
                 0% 41.6%, 41.6% 41.6%, 41.6% 0%, 58.4% 0%, 58.4% 41.6%, 100% 41.6%,
                 100% 58.4%, 58.4% 58.4%, 58.4% 100%, 41.6% 100%, 41.6% 58.4%, 0% 58.4%
             );
         }


        #block-selector {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.5); /* Slightly darker, more contrast */
            padding: 8px;
            border-radius: 5px;
            display: flex;
            gap: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 2px 10px rgba(0,0,0,0.4); /* Add subtle shadow */
        }
        .block-option {
            width: 45px;
            height: 45px;
            border: 2px solid grey;
            cursor: pointer;
            box-sizing: border-box;
            transition: border-color 0.2s, transform 0.15s ease-out, box-shadow 0.2s; /* Added transform/shadow transition */
            position: relative; /* Needed for potential pseudo-elements */
        }
         .block-option:hover {
             border-color: lightgrey;
             transform: scale(1.08); /* Scale up slightly on hover */
             box-shadow: 0 0 8px rgba(255,255,255,0.3); /* Add glow on hover */
         }
        .block-option.selected {
            border: 3px solid white;
            box-shadow: 0 0 12px rgba(255,255,255,0.6); /* Stronger glow when selected */
            transform: scale(1.1); /* Slightly larger when selected */
        }

        /* Enhanced Super Jump Prompt */
        #super-jump-prompt {
            position: absolute;
            bottom: 85px; /* Adjusted position slightly */
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to bottom, rgba(40,40,40,0.85), rgba(20,20,20,0.9)); /* Gradient background */
            padding: 8px 15px; /* More padding */
            border-radius: 6px;
            color: #f0f0f0; /* Lighter text */
            font-family: 'Arial', sans-serif;
            font-size: 1em; /* Slightly larger font */
            border: 1px solid rgba(255,255,255,0.3);
            text-align: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.5); /* Stronger shadow */
            display: flex; /* Use flex for icon alignment */
            align-items: center;
            gap: 8px; /* Space between icon and text */
            opacity: 0; /* Start hidden (controlled by JS) */
            visibility: hidden; /* Start hidden */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; /* Smooth fade */
            pointer-events: none; /* Prevent interaction */
        }
        #super-jump-prompt .jump-icon {
            font-size: 1.2em; /* Make icon slightly larger */
            color: #aaffff; /* Cyan color for icon */
            text-shadow: 0 0 5px #aaffff; /* Add a glow */
            display: inline-block;
            transform: translateY(-1px); /* Fine-tune vertical alignment */
        }
    </style>
</head>
<body>

<!-- Back Button -->
<a href="../index.html" class="back-circle">
  <i class="uil uil-estate"></i>
</a>

<style>
  .back-circle {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 50px;
    height: 50px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    text-decoration: none;
    backdrop-filter: blur(4px);
    transition: 0.2s ease, transform 0.2s ease;
    z-index: 9999;
    opacity: 1; /* always visible */
    pointer-events: auto;
  }

  .back-circle:hover {
    background: rgba(0, 0, 0, 0.9);
    transform: scale(1.1);
  }

  .back-circle i {
    font-size: 28px;
    color: white;
  }
</style>



    <!-- Blocker/Menu Screen -->
    <div id="blocker">
        <div id="menu">
            <h1>Voxel World</h1>
            <button id="start-button" class="menu-button">Start Game</button>
            <button id="settings-button" class="menu-button">Settings</button>
            <div id="settings-content">
                 <p><strong>Controls:</strong></p>
                 <p>W, A, S, D = Move</p>
                 <p>SPACE = Jump</p>
                 <p>Q = Super Jump</p>
                 <p>MOUSE = Look</p>
                 <p>Left Click = Break Block</p>
                 <p>Right Click = Place Block</p>
                 <p>1-6 = Select Block Type</p>
                 <p>ESC = Pause / Menu</p>
                 <p>SHIFT = Sprint</p>

                 <hr style="border-color: rgba(255,255,255,0.2); margin: 15px 0;">

                 <p><strong>Gameplay:</strong></p>
                 <div class="setting-item">
                     <label for="sprint-slider">Sprint Speed:</label>
                     <input type="range" id="sprint-slider" min="1.5" max="5.0" step="0.1" value="1.8">
                     <span id="sprint-speed-value">1.8x</span>
                 </div>

            </div>
             <p style="margin-top: 30px; font-size: 0.9em; color: #aaa;">Enhanced Edition</p>
        </div>
    </div>

    <!-- In-Game UI -->
    <div id="crosshair"></div>
    <div id="block-selector"></div>
    <!-- Super Jump Prompt -->
    <div id="super-jump-prompt">
        <span class="jump-icon">â¬†</span> Press [Q] for Super Jump
    </div>
    <canvas id="webgl"></canvas>

    <!-- Import maps for ES Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Main Game Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Constants ---
        const CHUNK_SIZE = 16;
        const CHUNK_HEIGHT = 128;
        const WORLD_HEIGHT_SCALE = 40;
        const NOISE_SCALE = 0.05;
        const RENDER_DISTANCE = 5; // Slightly increased render distance
        const PLAYER_HEIGHT = 1.7;
        const PLAYER_RADIUS = 0.4;
        const GRAVITY = -28; // Slightly stronger gravity
        const JUMP_VELOCITY = 9.5; // Slightly higher jump
        const MOVE_SPEED = 6; // Slightly faster movement
        const BLOCK_PLACE_DISTANCE = 6; // Increased reach
        const SPRINT_FOV_INCREASE = 10; // How much FOV increases when sprinting
        const SUPER_JUMP_FORWARD_IMPULSE = 25; // Forward force for super jump
        const SUPER_JUMP_VERTICAL_IMPULSE = 18; // Upward force for super jump

        const BLOCK_TYPES = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6,
            // Could add more: WATER, LAVA, BEDROCK, etc.
        };

        // Adjusted colors for slightly nicer look
        const BLOCK_COLORS = {
            [BLOCK_TYPES.GRASS]: { top: 0x55aa55, side: 0x8c6b4f, bottom: 0x8c6b4f }, // Greener top, browner sides
            [BLOCK_TYPES.DIRT]: { top: 0x8c6b4f, side: 0x8c6b4f, bottom: 0x8c6b4f }, // Earthy brown
            [BLOCK_TYPES.STONE]: { top: 0x8a8a8a, side: 0x8a8a8a, bottom: 0x8a8a8a }, // Slightly lighter stone
            [BLOCK_TYPES.WOOD]: { top: 0x6b4f2f, side: 0x7c5f3f, bottom: 0x6b4f2f }, // Wood colors
            [BLOCK_TYPES.LEAVES]: { top: 0x339933, side: 0x339933, bottom: 0x339933 }, // Vibrant leaves
            [BLOCK_TYPES.SAND]: { top: 0xe0d69b, side: 0xe0d69b, bottom: 0xe0d69b }, // Paler sand
        };

        const BLOCK_SELECT_ORDER = [
             BLOCK_TYPES.GRASS, BLOCK_TYPES.DIRT, BLOCK_TYPES.STONE,
             BLOCK_TYPES.WOOD, BLOCK_TYPES.LEAVES, BLOCK_TYPES.SAND
        ];

        // --- Perlin Noise (same as before) ---
        const PerlinNoise = new (function() { /* ... (Noise code identical to previous version) ... */
             this.p = new Uint8Array(512); this.permutation = [ 151,160,137,91,90,15, 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23, 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33, 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166, 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244, 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196, 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123, 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42, 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228, 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254, 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 ]; for (let i=0; i < 256 ; i++) this.p[256+i] = this.p[i] = this.permutation[i]; this.fade = function(t) { return t * t * t * (t * (t * 6 - 15) + 10); } ;this.lerp = function(t, a, b) { return a + t * (b - a); } ;this.grad = function(hash, x, y, z) { let h = hash & 15; let u = h<8 ? x : y, v = h<4 ? y : h==12||h==14 ? x : z; return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v); }; this.noise = function(x, y, z) { let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255; x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z); let u = this.fade(x), v = this.fade(y), w = this.fade(z); let A = this.p[X]+Y, AA = this.p[A]+Z, AB = this.p[A+1]+Z, B = this.p[X+1]+Y, BA = this.p[B]+Z, BB = this.p[B+1]+Z; return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x-1, y, z)), this.lerp(u, this.grad(this.p[AB], x, y-1, z), this.grad(this.p[BB], x-1, y-1, z))), this.lerp(v, this.lerp(u, this.grad(this.p[AA+1], x, y, z-1), this.grad(this.p[BA+1], x-1, y, z-1)), this.lerp(u, this.grad(this.p[AB+1], x, y-1, z-1), this.grad(this.p[BB+1], x-1, y-1, z-1)))); }; })();

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let world = {};
        let material; // Will be MeshStandardMaterial
        let playerVelocity = new THREE.Vector3();
        let playerOnGround = false;
        let clock = new THREE.Clock();
        let keys = {};
        let isSprinting = false; // Track sprinting state
        let sprintMultiplier = 1.8; // Default sprint multiplier
        let targetFov; // For smooth FOV transitions
        let originalFov; // Store the initial FOV
        let windLinesMesh = null; // For sprint visual effect
        let chunksToGenerate = [];
        let chunksToRemove = []; // Keep for potential future use
        let currentBlockType = BLOCK_TYPES.GRASS;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let outlineMesh; // For block highlighting
        let activeParticles = []; // Array to hold active particle systems

        let gameState = 'MENU'; // 'MENU', 'PLAYING', 'PAUSED'
        let menuCameraAnimation = { // Store animation state
            active: false,
            initialPosition: new THREE.Vector3(0, CHUNK_HEIGHT + 20, CHUNK_SIZE * 1.5),
            lookAtTarget: new THREE.Vector3(CHUNK_SIZE / 2, CHUNK_HEIGHT / 2, CHUNK_SIZE / 2)
        };

        // --- DOM Elements ---
        const blocker = document.getElementById('blocker');
        const menu = document.getElementById('menu');
        const startButton = document.getElementById('start-button');
        const settingsButton = document.getElementById('settings-button');
        const settingsContent = document.getElementById('settings-content');
        const crosshair = document.getElementById('crosshair');
        const blockSelectorUI = document.getElementById('block-selector');
        const superJumpPromptUI = document.getElementById('super-jump-prompt'); // Get the new prompt UI
        const sprintSlider = document.getElementById('sprint-slider');     // Still needed
        const sprintSpeedValueUI = document.getElementById('sprint-speed-value'); // Still needed

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Keep sky blue for in-game
            scene.fog = new THREE.Fog(0x87CEEB, RENDER_DISTANCE * CHUNK_SIZE * 0.4, RENDER_DISTANCE * CHUNK_SIZE * 1.1); // Adjusted fog

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, RENDER_DISTANCE * CHUNK_SIZE * 1.2); // Adjusted far plane
            camera.position.set(CHUNK_SIZE / 2, CHUNK_HEIGHT, CHUNK_SIZE / 2);
            originalFov = camera.fov; // Store the original FOV
            targetFov = originalFov; // Initialize target FOV

            // Renderer
            const canvas = document.getElementById('webgl');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            // renderer.toneMapping = THREE.ACESFilmicToneMapping; // Optional: Improves color/contrast
            // renderer.toneMappingExposure = 1.0;

            // Lighting Enhancement
            // scene.add(new THREE.AmbientLight(0x666666)); // Reduced ambient
            scene.add(new THREE.HemisphereLight(0x87CEEB, 0x9c7a50, 0.8)); // Sky, Ground, Intensity

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8); // Slightly increased intensity
            directionalLight.position.set(80, 120, 60); // Adjusted angle
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; // Higher resolution shadow map
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 10; // Adjusted shadow camera planes
            directionalLight.shadow.camera.far = 300;
            const shadowCamSize = RENDER_DISTANCE * CHUNK_SIZE * 0.7; // Tighter shadow frustum
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            directionalLight.shadow.bias = -0.0005; // Reduce shadow acne
            scene.add(directionalLight);
            // scene.add( new THREE.CameraHelper( directionalLight.shadow.camera ) ); // Debug

            // Material (PBR)
            material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.9, // Make blocks look rough
                metalness: 0.0, // Non-metallic
                // side: THREE.DoubleSide, // Use only if seeing backfaces is needed (performance cost)
            });

            // Block Outline Mesh
            const outlineGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01); // Slightly larger than block
            const outlineMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.8 });
            outlineMesh = new THREE.Mesh(outlineGeometry, outlineMaterial);
            outlineMesh.visible = false;
            scene.add(outlineMesh);

            // Controls & Menu Logic
            setupControls();
            setupMenu();
            setupSprintUI(); // Setup the sprint slider (now in settings)
            createWindLines(); // Create the geometry for wind lines

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', handleKeyDown); // Use single handler
            document.addEventListener('keyup', (event) => { keys[event.code] = false; });
            document.addEventListener('mousedown', onMouseDown);

            // UI Setup
            setupBlockSelector();

            // Initial state
            showMenu(); // Setup menu state, including camera
            preloadInitialChunks(); // Generate some chunks for the menu background

            // Start Game Loop
            animate();
        }

        // --- Preload Chunks for Menu ---
        function preloadInitialChunks() {
            // Generate a small area around the center for the menu view
            const preloadRadius = 2; // Load a 5x5 chunk area (adjust as needed)
            console.log("Preloading initial chunks for menu...");
            for (let x = -preloadRadius; x <= preloadRadius; x++) {
                for (let z = -preloadRadius; z <= preloadRadius; z++) {
                    generateChunkData(x, z);
                }
            }
            // Immediately process these initial chunks' meshes
            processChunkMeshUpdates(); // Process scheduled updates (should be none yet)
             // Force generation of meshes added to chunksToGenerate queue
             while(chunksToGenerate.length > 0) {
                  const { chunkX, chunkZ } = chunksToGenerate.shift();
                  generateChunkMesh(chunkX, chunkZ);
             }
             console.log("Initial chunk loading complete.");
        }

        // --- Menu and State Management ---
        function setupMenu() {
            startButton.addEventListener('click', startGame);
            settingsButton.addEventListener('click', toggleSettings);
        }

        function startGame() {
            const resuming = gameState === 'PAUSED'; // Check if resuming

            gameState = 'PLAYING';
            menuCameraAnimation.active = false; // Stop menu animation if it was running
            blocker.style.display = 'none'; // Hide menu overlay FIRST
            crosshair.style.display = 'block'; // Use block for the new crosshair style
            blockSelectorUI.style.display = 'flex';
            // superJumpPromptUI visibility is handled in updatePlayer

            if (!resuming) {
                // Only reset position and rotation if starting a NEW game
                camera.position.set(CHUNK_SIZE / 2, CHUNK_HEIGHT, CHUNK_SIZE / 2);
                camera.rotation.set(0, 0, 0); // Reset rotation before controls take over
                controls.getObject().position.copy(camera.position); // Sync controls position
                playerVelocity.set(0,0,0); // Reset velocity only on new game
            }

            // Reset things needed for both start and resume
            camera.fov = originalFov; // Ensure FOV is reset
            camera.updateProjectionMatrix();
            targetFov = originalFov; // Reset FOV target
            keys = {}; // Clear keys on start/resume
            isSprinting = false; // Ensure not sprinting on start/resume

            // Change button text back if needed - optional
            // startButton.textContent = "Start Game";

            // REMOVED: controls.lock(); - Don't call lock directly here.
            // The user needs to click the game window after the menu hides.
        }

        function showMenu() {
            // This function is now ONLY for the initial main menu state
            gameState = 'MENU';
            menuCameraAnimation.active = true; // Start menu animation
            blocker.style.display = 'flex'; // Show menu overlay
            crosshair.style.display = 'none'; // Hide crosshair in menu
            blockSelectorUI.style.display = 'none';
            // superJumpPromptUI visibility handled by opacity/visibility now
            superJumpPromptUI.style.opacity = '0';
            superJumpPromptUI.style.visibility = 'hidden';
            settingsContent.style.display = 'none'; // Ensure settings are hidden initially
            controls.unlock(); // Make sure controls are unlocked
            isSprinting = false; // Stop sprinting effects if menu opens
            if (windLinesMesh) windLinesMesh.visible = false;

            // Set initial camera for menu animation
            camera.position.copy(menuCameraAnimation.initialPosition);
            camera.lookAt(menuCameraAnimation.lookAtTarget);
            camera.fov = originalFov; // Use standard FOV for menu
            camera.updateProjectionMatrix();

            // Ensure start button text is correct for main menu - optional
            // startButton.textContent = "Start Game";
        }

        function toggleSettings() {
             settingsContent.style.display = settingsContent.style.display === 'none' ? 'block' : 'none';
        }

        function pauseGame() {
            gameState = 'PAUSED';
            blocker.style.display = 'flex'; // Show menu overlay
            crosshair.style.display = 'none'; // Hide crosshair when paused
            blockSelectorUI.style.display = 'none';
            // superJumpPromptUI visibility handled by opacity/visibility now
            superJumpPromptUI.style.opacity = '0';
            superJumpPromptUI.style.visibility = 'hidden';
            settingsContent.style.display = 'none'; // Ensure settings are hidden initially when pausing

            // Stop player effects immediately
            isSprinting = false;
            if (windLinesMesh) windLinesMesh.visible = false;
            targetFov = originalFov; // Reset FOV target
            camera.fov = originalFov; // Snap FOV back immediately
            camera.updateProjectionMatrix();

            // Menu button text might need changing (e.g., "Resume Game") - optional
            // startButton.textContent = "Resume Game";

            controls.unlock(); // Ensure controls are unlocked
        }

        // --- Controls Setup ---
        function setupControls() {
            controls = new PointerLockControls(camera, document.body);

            // Add listener to handle locking on click when in PLAYING state
            document.body.addEventListener('click', () => {
                // Only try to lock if we are in the playing state and not already locked
                if (gameState === 'PLAYING' && !controls.isLocked) {
                    controls.lock();
                }
            });

            controls.addEventListener('lock', () => {
                // This now correctly fires *after* the user clicks the game window
                // and the lock is successfully acquired.
                if (gameState === 'PLAYING') { // Double-check state just in case
                     blocker.style.display = 'none'; // Ensure blocker is hidden
                     crosshair.style.display = 'block'; // Use block for new crosshair style
                     blockSelectorUI.style.display = 'flex';
                     keys = {}; // Optional: clear keys on lock/unlock transition
                } else {
                     // If somehow locked while not playing, unlock immediately
                     console.warn("Controls locked unexpectedly in state:", gameState);
                     controls.unlock();
                }
            });

            controls.addEventListener('unlock', () => {
                // This listener now handles transitions *caused* by unlocking (e.g., ESC)
                if (gameState === 'PLAYING') {
                    // If we were playing, unlocking means pausing
                    pauseGame();
                } else if (gameState === 'MENU') {
                    // If we were in the main menu, unlocking doesn't change state
                    // (Should already be unlocked, but safety check)
                    showMenu(); // Ensure menu state is correct if somehow locked
                }
                // If gameState is 'PAUSED', unlocking doesn't change the state here,
                // it just confirms the controls are unlocked.
            });

            scene.add(controls.getObject());
        }

         // --- Input Handling ---
         function handleKeyDown(event) {
             keys[event.code] = true;

             // Handle non-movement keys immediately
             if (gameState === 'PLAYING') {
                 // Sprinting check (Shift keys)
                 if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                     if (!isSprinting) {
                         isSprinting = true;
                         targetFov = originalFov + SPRINT_FOV_INCREASE; // Target increased FOV
                         if (windLinesMesh) windLinesMesh.visible = true; // Show wind lines
                     }
                 }

                 // Super Jump (Let's use 'KeyQ' because why not?)
                 if (event.code === 'KeyQ' && playerOnGround) { // Only jump from ground for now
                     const direction = new THREE.Vector3();
                     camera.getWorldDirection(direction);
                     direction.normalize();

                     // Apply impulse: forward and up
                     playerVelocity.y = SUPER_JUMP_VERTICAL_IMPULSE; // Instant vertical boost
                     playerVelocity.addScaledVector(direction, SUPER_JUMP_FORWARD_IMPULSE);

                     playerOnGround = false; // We are definitely not on the ground anymore
                     createJumpParticles(camera.position.clone().sub(new THREE.Vector3(0, PLAYER_HEIGHT - PLAYER_RADIUS, 0))); // Particles at feet
                     // Hide prompt immediately on jump (opacity/visibility handled in updatePlayer)
                     // superJumpPromptUI.style.display = 'none';
                 }

                 // Number keys 1-6 for block selection
                 const num = parseInt(event.code.replace('Digit', ''));
                 if (num >= 1 && num <= BLOCK_SELECT_ORDER.length) {
                     const selectedType = BLOCK_SELECT_ORDER[num - 1];
                     if (selectedType !== BLOCK_TYPES.AIR) {
                         currentBlockType = selectedType;
                         updateSelectedBlockUI();
                     }
                 }
             }

              // Escape key always works to show menu/pause
              if (event.code === 'Escape') {
                  if (gameState === 'PLAYING') {
                       // Unlocking when playing will trigger the pauseGame() via the listener
                       controls.unlock();
                  } else if (gameState === 'PAUSED' || gameState === 'MENU') {
                       // Optional: If settings are open in pause/menu, close them
                       if (settingsContent.style.display === 'block') {
                            toggleSettings();
                       }
                       // Otherwise, ESC does nothing further in these states
                  }
              }
         }

         // Need to handle KeyUp for sprinting
         document.addEventListener('keyup', (event) => {
             keys[event.code] = false;

             // Stop sprinting when Shift is released
             if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                 // Check if *any* shift key is still held down (unlikely but possible)
                 if (!keys['ShiftLeft'] && !keys['ShiftRight']) {
                     isSprinting = false;
                     targetFov = originalFov; // Target original FOV
                     // Wind lines visibility is handled in updatePlayer/animate now
                     // if (windLinesMesh) windLinesMesh.visible = false;
                 }
             }
         });


        // --- World Generation & Management (Mostly unchanged, minor tweaks possible) ---

        function worldToChunkCoords(x, y, z) { /* ... (identical) ... */
             const chunkX = Math.floor(x / CHUNK_SIZE); const chunkZ = Math.floor(z / CHUNK_SIZE); const localX = THREE.MathUtils.euclideanModulo(x, CHUNK_SIZE); const localY = Math.floor(y); const localZ = THREE.MathUtils.euclideanModulo(z, CHUNK_SIZE); return { chunkX, chunkZ, localX, localY, localZ }; }
        function getChunkKey(chunkX, chunkZ) { /* ... (identical) ... */
             return `${chunkX},${chunkZ}`; }
        function getBlockIndex(localX, localY, localZ) { /* ... (identical) ... */
             if (localX < 0 || localX >= CHUNK_SIZE || localY < 0 || localY >= CHUNK_HEIGHT || localZ < 0 || localZ >= CHUNK_SIZE) { return -1; } return localY * CHUNK_SIZE * CHUNK_SIZE + localZ * CHUNK_SIZE + localX; }
        function getBlock(x, y, z) { /* ... (identical) ... */
             const { chunkX, chunkZ, localX, localY, localZ } = worldToChunkCoords(x, y, z); const chunkKey = getChunkKey(chunkX, chunkZ); const chunk = world[chunkKey]; if (!chunk || !chunk.blocks || localY < 0 || localY >= CHUNK_HEIGHT) { return BLOCK_TYPES.AIR; } const blockIndex = getBlockIndex(localX, localY, localZ); if (blockIndex === -1) return BLOCK_TYPES.AIR; return chunk.blocks[blockIndex]; }
        function setBlock(x, y, z, type) { /* ... (identical, triggers mesh update) ... */
             const { chunkX, chunkZ, localX, localY, localZ } = worldToChunkCoords(x, y, z); const chunkKey = getChunkKey(chunkX, chunkZ); const chunk = world[chunkKey]; if (!chunk || !chunk.blocks || localY < 0 || localY >= CHUNK_HEIGHT) { console.warn(`Attempted to set block outside loaded chunk or height: ${x},${y},${z}`); return; } const blockIndex = getBlockIndex(localX, localY, localZ); if (blockIndex === -1) { console.warn(`Attempted to set block with invalid local coords: ${localX},${localY},${localZ}`); return; } if (chunk.blocks[blockIndex] !== type) { chunk.blocks[blockIndex] = type; scheduleChunkMeshUpdate(chunkX, chunkZ); if (localX === 0) scheduleChunkMeshUpdate(chunkX - 1, chunkZ); if (localX === CHUNK_SIZE - 1) scheduleChunkMeshUpdate(chunkX + 1, chunkZ); if (localZ === 0) scheduleChunkMeshUpdate(chunkX, chunkZ - 1); if (localZ === CHUNK_SIZE - 1) scheduleChunkMeshUpdate(chunkX, chunkZ + 1); } }
        const scheduledMeshUpdates = new Set(); function scheduleChunkMeshUpdate(chunkX, chunkZ) { /* ... (identical) ... */
             const key = getChunkKey(chunkX, chunkZ); if (world[key] && !scheduledMeshUpdates.has(key)) { scheduledMeshUpdates.add(key); } }
        function processChunkMeshUpdates() { /* ... (identical) ... */
             scheduledMeshUpdates.forEach(key => { const coords = key.split(','); const chunkX = parseInt(coords[0]); const chunkZ = parseInt(coords[1]); generateChunkMesh(chunkX, chunkZ); }); scheduledMeshUpdates.clear(); }
        function getBlockLocalOrNeighbor(currentChunkX, currentChunkZ, localX, localY, localZ) { /* ... (identical) ... */
             if (localY < 0 || localY >= CHUNK_HEIGHT) return BLOCK_TYPES.AIR; let targetChunkX = currentChunkX; let targetChunkZ = currentChunkZ; let targetLocalX = localX; let targetLocalZ = localZ; if (localX < 0) { targetChunkX--; targetLocalX = CHUNK_SIZE - 1; } else if (localX >= CHUNK_SIZE) { targetChunkX++; targetLocalX = 0; } if (localZ < 0) { targetChunkZ--; targetLocalZ = CHUNK_SIZE - 1; } else if (localZ >= CHUNK_SIZE) { targetChunkZ++; targetLocalZ = 0; } const chunkKey = getChunkKey(targetChunkX, targetChunkZ); const chunk = world[chunkKey]; if (!chunk || !chunk.blocks) { return (localY < CHUNK_HEIGHT / 2) ? BLOCK_TYPES.STONE : BLOCK_TYPES.AIR; } const blockIndex = getBlockIndex(targetLocalX, localY, targetLocalZ); if (blockIndex === -1) return BLOCK_TYPES.AIR; return chunk.blocks[blockIndex]; }


        function generateChunkData(chunkX, chunkZ) { // Slightly adjusted tree generation
            const chunkKey = getChunkKey(chunkX, chunkZ);
            if (world[chunkKey]) return;

            const chunk = {
                blocks: new Uint8Array(CHUNK_SIZE * CHUNK_HEIGHT * CHUNK_SIZE),
                mesh: null
            };
            world[chunkKey] = chunk;

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const worldX = chunkX * CHUNK_SIZE + x;
                    const worldZ = chunkZ * CHUNK_SIZE + z;

                    const noiseVal = (PerlinNoise.noise(worldX * NOISE_SCALE, worldZ * NOISE_SCALE, 0) + 1) / 2;
                    const surfaceHeight = Math.floor(noiseVal * WORLD_HEIGHT_SCALE) + Math.floor(CHUNK_HEIGHT / 3);
                    const baseLevel = Math.floor(CHUNK_HEIGHT / 3);

                    for (let y = 0; y < CHUNK_HEIGHT; y++) {
                        const blockIndex = getBlockIndex(x, y, z);
                        let blockType = BLOCK_TYPES.AIR;

                        if (y === 0) {
                            blockType = BLOCK_TYPES.STONE; // Bedrock-like layer
                        } else if (y < surfaceHeight - 3) {
                            blockType = BLOCK_TYPES.STONE;
                        } else if (y < surfaceHeight) {
                            if (surfaceHeight <= baseLevel + 2 && y > baseLevel -2) { // Sandy shores near water level
                                 blockType = BLOCK_TYPES.SAND;
                            } else {
                                blockType = BLOCK_TYPES.DIRT;
                            }
                        } else if (y === surfaceHeight) {
                             if (surfaceHeight <= baseLevel + 2) {
                                 blockType = BLOCK_TYPES.SAND;
                             } else {
                                blockType = BLOCK_TYPES.GRASS;
                            }
                        }
                        chunk.blocks[blockIndex] = blockType;
                    }

                    // Trees (slightly denser chance)
                    if (chunk.blocks[getBlockIndex(x, surfaceHeight, z)] === BLOCK_TYPES.GRASS) {
                        if (Math.random() < 0.015) { // 1.5% chance
                            const treeHeight = Math.floor(Math.random() * 3) + 4;
                            for(let ty = 1; ty <= treeHeight; ty++) {
                                if (surfaceHeight + ty < CHUNK_HEIGHT) {
                                    chunk.blocks[getBlockIndex(x, surfaceHeight + ty, z)] = BLOCK_TYPES.WOOD;
                                }
                            }
                            // Leaves (slightly larger radius)
                            const leafRadius = Math.random() < 0.3 ? 3 : 2; // Occasional bigger trees
                            const leafStartY = surfaceHeight + treeHeight - 1;
                            const leafEndY = surfaceHeight + treeHeight + (leafRadius > 2 ? 2 : 1);

                            for (let ly = leafStartY; ly <= leafEndY; ly++) {
                                for (let lx = -leafRadius; lx <= leafRadius; lx++) {
                                    for (let lz = -leafRadius; lz <= leafRadius; lz++) {
                                         let distSq = lx*lx + lz*lz + (ly - (leafStartY + 1))*(ly - (leafStartY + 1))*0.8; // Ellipsoid shape
                                         if (distSq <= leafRadius * leafRadius + Math.random() * 0.5) { // More natural shape
                                             const currentBlockIndex = getBlockIndex(x + lx, ly, z + lz);
                                             if (ly < CHUNK_HEIGHT && currentBlockIndex !== -1 &&
                                                 (x + lx >= 0 && x + lx < CHUNK_SIZE && z + lz >= 0 && z + lz < CHUNK_SIZE) && // Stay in chunk bounds for simplicity
                                                 chunk.blocks[currentBlockIndex] === BLOCK_TYPES.AIR)
                                             {
                                                 chunk.blocks[currentBlockIndex] = BLOCK_TYPES.LEAVES;
                                             }
                                         }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            chunksToGenerate.push({ chunkX, chunkZ });
        }

        function generateChunkMesh(chunkX, chunkZ) { // Minor color multiplier adjustments
            const chunkKey = getChunkKey(chunkX, chunkZ);
            const chunk = world[chunkKey];
            if (!chunk || !chunk.blocks) return;

            if (chunk.mesh) {
                scene.remove(chunk.mesh);
                chunk.mesh.geometry.dispose();
                chunk.mesh = null;
            }

            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];
            let vertexIndex = 0;

            // Color multipliers for fake AO / shading
            const AO_FACTOR = 0.75; // How dark AO corners are
            const TOP_BRIGHTNESS = 1.0; // Top face brightness (already handled by lighting mostly)
            const SIDE_BRIGHTNESS = 0.85;
            const BOTTOM_BRIGHTNESS = 0.6;

            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    for (let x = 0; x < CHUNK_SIZE; x++) {
                        const blockType = chunk.blocks[getBlockIndex(x, y, z)];
                        if (blockType === BLOCK_TYPES.AIR) continue;

                        const blockColorData = BLOCK_COLORS[blockType] || { top: 0x777777, side: 0x777777, bottom: 0x777777 };

                        const neighbors = {
                            nx: getBlockLocalOrNeighbor(chunkX, chunkZ, x - 1, y, z) !== BLOCK_TYPES.AIR,
                            px: getBlockLocalOrNeighbor(chunkX, chunkZ, x + 1, y, z) !== BLOCK_TYPES.AIR,
                            ny: getBlockLocalOrNeighbor(chunkX, chunkZ, x, y - 1, z) !== BLOCK_TYPES.AIR,
                            py: getBlockLocalOrNeighbor(chunkX, chunkZ, x, y + 1, z) !== BLOCK_TYPES.AIR,
                            nz: getBlockLocalOrNeighbor(chunkX, chunkZ, x, y, z - 1) !== BLOCK_TYPES.AIR,
                            pz: getBlockLocalOrNeighbor(chunkX, chunkZ, x, y, z + 1) !== BLOCK_TYPES.AIR,
                        };

                        const blockWorldX = chunkX * CHUNK_SIZE + x;
                        const blockWorldY = y;
                        const blockWorldZ = chunkZ * CHUNK_SIZE + z;

                        // --- Generate faces ---
                        // (Vertex order: BL, BR, TR, TL relative to face normal)

                        // Positive Z (+z)
                        if (!neighbors.pz) {
                            const faceColor = new THREE.Color(blockColorData.side);
                            const C = SIDE_BRIGHTNESS;
                            positions.push(blockWorldX, blockWorldY, blockWorldZ + 1, blockWorldX + 1, blockWorldY, blockWorldZ + 1, blockWorldX + 1, blockWorldY + 1, blockWorldZ + 1, blockWorldX, blockWorldY + 1, blockWorldZ + 1);
                            normals.push(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
                            colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C);
                            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4;
                        }
                        // Negative Z (-z)
                        if (!neighbors.nz) {
                            const faceColor = new THREE.Color(blockColorData.side);
                            const C = SIDE_BRIGHTNESS;
                            positions.push(blockWorldX + 1, blockWorldY, blockWorldZ, blockWorldX, blockWorldY, blockWorldZ, blockWorldX, blockWorldY + 1, blockWorldZ, blockWorldX + 1, blockWorldY + 1, blockWorldZ);
                            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
                            colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C);
                            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4;
                        }
                        // Positive X (+x)
                        if (!neighbors.px) {
                            const faceColor = new THREE.Color(blockColorData.side);
                            const C = SIDE_BRIGHTNESS;
                            positions.push(blockWorldX + 1, blockWorldY, blockWorldZ + 1, blockWorldX + 1, blockWorldY, blockWorldZ, blockWorldX + 1, blockWorldY + 1, blockWorldZ, blockWorldX + 1, blockWorldY + 1, blockWorldZ + 1);
                            normals.push(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0);
                            colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C);
                            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4;
                        }
                         // Negative X (-x)
                        if (!neighbors.nx) {
                            const faceColor = new THREE.Color(blockColorData.side);
                            const C = SIDE_BRIGHTNESS;
                            positions.push(blockWorldX, blockWorldY, blockWorldZ, blockWorldX, blockWorldY, blockWorldZ + 1, blockWorldX, blockWorldY + 1, blockWorldZ + 1, blockWorldX, blockWorldY + 1, blockWorldZ);
                            normals.push(-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0);
                            colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C);
                            indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4;
                        }
                        // Positive Y (+y) - Top
                        if (!neighbors.py) {
                             const faceColor = new THREE.Color(blockColorData.top);
                             const C = TOP_BRIGHTNESS;
                             positions.push(blockWorldX, blockWorldY + 1, blockWorldZ + 1, blockWorldX + 1, blockWorldY + 1, blockWorldZ + 1, blockWorldX + 1, blockWorldY + 1, blockWorldZ, blockWorldX, blockWorldY + 1, blockWorldZ);
                             normals.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);
                             colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C);
                             indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4;
                        }
                        // Negative Y (-y) - Bottom
                        if (!neighbors.ny) {
                             const faceColor = new THREE.Color(blockColorData.bottom);
                             const C = BOTTOM_BRIGHTNESS;
                             positions.push(blockWorldX, blockWorldY, blockWorldZ, blockWorldX + 1, blockWorldY, blockWorldZ, blockWorldX + 1, blockWorldY, blockWorldZ + 1, blockWorldX, blockWorldY, blockWorldZ + 1);
                             normals.push(0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0);
                             colors.push(faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C, faceColor.r * C, faceColor.g * C, faceColor.b * C);
                             indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2, vertexIndex, vertexIndex + 2, vertexIndex + 3); vertexIndex += 4;
                        }
                    }
                }
            }

            if (positions.length === 0) return;

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            // geometry.computeVertexNormals(); // Recompute normals if needed, but we supply them

            chunk.mesh = new THREE.Mesh(geometry, material);
            chunk.mesh.castShadow = true;
            chunk.mesh.receiveShadow = true;
            chunk.mesh.userData = { chunkX, chunkZ };
            scene.add(chunk.mesh);
        }


        function updateWorldChunks() {
            let camX, camZ, currentChunkX, currentChunkZ;

            if (gameState === 'PLAYING') {
                // Use player camera position for chunk loading during gameplay
                camX = camera.position.x;
                camZ = camera.position.z;
            } else if (menuCameraAnimation.active) {
                // Use menu camera position for chunk loading when menu is active
                // This ensures the background view remains populated
                camX = camera.position.x;
                camZ = camera.position.z;
            } else {
                // Should not happen, but default to 0,0
                camX = 0;
                camZ = 0;
            }

            currentChunkX = Math.floor(camX / CHUNK_SIZE);
            currentChunkZ = Math.floor(camZ / CHUNK_SIZE);

            const effectiveRenderDistance = (gameState === 'PLAYING') ? RENDER_DISTANCE : 3; // Use smaller radius for menu?

            // Chunk Loading/Generation
            for (let x = currentChunkX - effectiveRenderDistance; x <= currentChunkX + effectiveRenderDistance; x++) {
                for (let z = currentChunkZ - effectiveRenderDistance; z <= currentChunkZ + effectiveRenderDistance; z++) {
                    const chunkKey = getChunkKey(x, z);
                    if (!world[chunkKey]) {
                        generateChunkData(x, z);
                    } else if (world[chunkKey].mesh === null && !chunksToGenerate.some(c => c.chunkX === x && c.chunkZ === z) && !scheduledMeshUpdates.has(chunkKey) ) {
                        chunksToGenerate.push({ chunkX: x, chunkZ: z });
                    }
                }
            }

             // Process Mesh Generation Queue (Generates meshes for newly created data)
             const maxMeshesPerFrame = (gameState === 'PLAYING') ? 3 : 5; // Allow more mesh gen in menu?
             for (let i = 0; i < maxMeshesPerFrame && chunksToGenerate.length > 0; i++) {
                 const { chunkX, chunkZ } = chunksToGenerate.shift();
                 // Check distance again in case camera moved significantly
                 if (Math.abs(chunkX - currentChunkX) <= effectiveRenderDistance && Math.abs(chunkZ - currentChunkZ) <= effectiveRenderDistance) {
                     generateChunkMesh(chunkX, chunkZ);
                 } else {
                     // If it fell out of range while queued, put it back? Or just drop? For now, drop.
                 }
             }

            // Process Mesh Updates Queue (Handles updates from block changes)
            processChunkMeshUpdates();

            // Chunk Unloading (Only unload chunks far from the *player* camera during gameplay)
            // Avoid unloading chunks needed for the menu view
            if (gameState === 'PLAYING') {
                const playerChunkX = Math.floor(camera.position.x / CHUNK_SIZE);
                const playerChunkZ = Math.floor(camera.position.z / CHUNK_SIZE);
                const unloadDistance = RENDER_DISTANCE + 2; // Unload slightly further than render distance
                const chunksToKeep = new Set();
                for (let x = playerChunkX - unloadDistance; x <= playerChunkX + unloadDistance; x++) {
                    for (let z = playerChunkZ - unloadDistance; z <= playerChunkZ + unloadDistance; z++) {
                        chunksToKeep.add(getChunkKey(x,z));
                    }
                }

                for (const chunkKey in world) {
                    if (!chunksToKeep.has(chunkKey)) {
                        const chunk = world[chunkKey];
                        if (chunk.mesh) {
                             scene.remove(chunk.mesh);
                             chunk.mesh.geometry.dispose();
                             chunk.mesh = null; // Mark mesh for regeneration if needed later
                        }
                        // Optionally delete data: delete world[chunkKey]; (saves RAM, costs regeneration)
                        // Be careful with deleting data if menu needs it. Maybe only unload mesh.
                    }
                }
            }
        }

        // --- Player Movement & Physics (Corrected Strafe) ---
        function updatePlayer(deltaTime) {
            const wasOnGround = playerOnGround; // Store previous ground state

            // No need to check controls.isLocked here, as this is only called when gameState is PLAYING
            const currentSpeed = isSprinting ? MOVE_SPEED * sprintMultiplier : MOVE_SPEED; // Use multiplier
            const direction = new THREE.Vector3();
            const right = new THREE.Vector3();

            controls.getDirection(direction);
            // **FIXED:** Use direction x up for the vector pointing to the camera's right
            // Actually, the cross product camera.up x forward points LEFT.
            // So we need to adjust how A and D affect moveRight.
            // right.crossVectors(direction, camera.up).normalize(); // This vector points right relative to camera

            let moveForward = 0;
            let moveRight = 0;

            // Standard WASD
            if (keys['KeyW']) moveForward += 1;
            if (keys['KeyS']) moveForward -= 1;
            // **FIXED A/D INVERSION:**
            // If 'A' is pressed, we want to move left. Since the 'sideways' vector points left, we ADD to moveRight.
            if (keys['KeyA']) moveRight += 1;
            // If 'D' is pressed, we want to move right. Since the 'sideways' vector points left, we SUBTRACT from moveRight.
            if (keys['KeyD']) moveRight -= 1;

            const moveDirection = new THREE.Vector3();
            // Use camera's forward direction projected onto XZ plane for movement
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const sideways = new THREE.Vector3();
            // sideways = camera.up x forward (points left)
            sideways.crossVectors(camera.up, forward).normalize();

            moveDirection.addScaledVector(forward, moveForward);
            // Apply movement along the 'sideways' vector (which points left)
            // If moveRight is +1 (from A), we move left. If -1 (from D), we move right.
            moveDirection.addScaledVector(sideways, moveRight);

            // Normalize diagonal movement
            if (moveDirection.lengthSq() > 0.1) { // Use a small threshold
                 moveDirection.normalize();
            }


            const deltaPosition = moveDirection.multiplyScalar(currentSpeed * deltaTime);

            // Gravity
            playerVelocity.y += GRAVITY * deltaTime;

            // Jump (Normal) - Don't jump if super jumping this frame
            if (keys['Space'] && playerOnGround && playerVelocity.y < JUMP_VELOCITY) { // Check velocity to avoid double jump with super jump
                playerVelocity.y = JUMP_VELOCITY;
                playerOnGround = false;
            }

            // Apply movement and gravity velocity
            const totalDelta = deltaPosition.clone().add(playerVelocity.clone().multiplyScalar(deltaTime));

            // --- Collision Detection (same logic, but higher speeds might cause issues) ---
            // WARNING: Very high speeds from the slider might cause tunneling!
            const playerBox = new THREE.Box3( /* ... (identical setup) ... */
                 new THREE.Vector3(camera.position.x - PLAYER_RADIUS, camera.position.y - (PLAYER_HEIGHT - PLAYER_RADIUS), camera.position.z - PLAYER_RADIUS), new THREE.Vector3(camera.position.x + PLAYER_RADIUS, camera.position.y + PLAYER_RADIUS, camera.position.z + PLAYER_RADIUS) );
            // playerOnGround = false; // Resetting here was incorrect, reset before collision checks

             // --- Collision Detection ---
             playerOnGround = false; // Assume not on ground until proven otherwise by vertical collision

             const nextPosX = camera.position.clone().add(new THREE.Vector3(totalDelta.x, 0, 0));
             if (!checkCollision(nextPosX)) { camera.position.x = nextPosX.x; } else { playerVelocity.x = 0; }

             const nextPosZ = camera.position.clone().add(new THREE.Vector3(0, 0, totalDelta.z));
             if (!checkCollision(nextPosZ)) { camera.position.z = nextPosZ.z; } else { playerVelocity.z = 0; }

             const nextPosY = camera.position.clone().add(new THREE.Vector3(0, totalDelta.y, 0));
             if (!checkCollision(nextPosY)) {
                 camera.position.y = nextPosY.y;
             } else {
                 if (totalDelta.y < 0) { // Hitting ground
                     if (!wasOnGround) { // Check if we *just* landed
                         createLandingParticles(camera.position.clone().sub(new THREE.Vector3(0, PLAYER_HEIGHT - PLAYER_RADIUS, 0))); // Particles at feet on landing
                     }
                     playerOnGround = true;
                     // Adjust position precisely to ground level + player height offset
                     // Find the Y coordinate of the block we collided with below us
                     const checkY = Math.floor(playerBox.min.y + totalDelta.y); // Potential ground block Y
                     const groundY = checkY + 1; // The top surface of that block
                     camera.position.y = groundY + (PLAYER_HEIGHT - PLAYER_RADIUS); // Place feet exactly on top
                 } else if (totalDelta.y > 0) {
                     // Hitting ceiling - adjust position slightly below ceiling
                     const checkY = Math.ceil(playerBox.max.y + totalDelta.y); // Potential ceiling block Y
                     const ceilingY = checkY; // The bottom surface of that block
                     camera.position.y = ceilingY - PLAYER_RADIUS - 0.01; // Place head just below
                 }
                 playerVelocity.y = 0; // Stop vertical movement on collision
             }


            // Prevent falling through the absolute bottom (y=0)
            if (camera.position.y < 0 + (PLAYER_HEIGHT - PLAYER_RADIUS)) {
                 if (!wasOnGround && playerVelocity.y <= 0) { // Check if just landed on y=0
                     createLandingParticles(camera.position.clone().setY(0)); // Particles at y=0
                 }
                 camera.position.y = 0 + (PLAYER_HEIGHT - PLAYER_RADIUS);
                 playerVelocity.y = 0;
                 playerOnGround = true;
            }

            // Update Super Jump prompt visibility using opacity/visibility for transitions
            const shouldShowPrompt = playerOnGround && gameState === 'PLAYING';
            if (shouldShowPrompt) {
                superJumpPromptUI.style.opacity = '1';
                superJumpPromptUI.style.visibility = 'visible';
            } else {
                superJumpPromptUI.style.opacity = '0';
                superJumpPromptUI.style.visibility = 'hidden';
            }

            // Apply damping/friction to horizontal velocity (prevents infinite sliding after super jump)
            // Only apply if not actively moving with WASD keys
            if (!keys['KeyW'] && !keys['KeyS'] && !keys['KeyA'] && !keys['KeyD'] && playerOnGround) {
                 playerVelocity.x *= 0.85; // Adjust friction factor as needed
                 playerVelocity.z *= 0.85;
            } else if (!playerOnGround) {
                 // Less air friction
                 playerVelocity.x *= 0.98;
                 playerVelocity.z *= 0.98;
            }

            // Smooth FOV transition
            const fovLerpFactor = 0.1; // Adjust for faster/slower FOV change
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, fovLerpFactor);
            camera.updateProjectionMatrix();

            // Update wind lines effect
            updateWindLines(deltaTime);
        }

        function checkCollision(newPos) { /* ... (identical collision logic) ... */
             const playerBox = new THREE.Box3( new THREE.Vector3(newPos.x - PLAYER_RADIUS, newPos.y - (PLAYER_HEIGHT - PLAYER_RADIUS), newPos.z - PLAYER_RADIUS), new THREE.Vector3(newPos.x + PLAYER_RADIUS, newPos.y + PLAYER_RADIUS, newPos.z + PLAYER_RADIUS) ); const minX = Math.floor(playerBox.min.x); const maxX = Math.ceil(playerBox.max.x); const minY = Math.floor(playerBox.min.y); const maxY = Math.ceil(playerBox.max.y); const minZ = Math.floor(playerBox.min.z); const maxZ = Math.ceil(playerBox.max.z); for (let y = minY; y < maxY; y++) { for (let z = minZ; z < maxZ; z++) { for (let x = minX; x < maxX; x++) { const blockType = getBlock(x, y, z); if (blockType !== BLOCK_TYPES.AIR) { const blockBox = new THREE.Box3( new THREE.Vector3(x, y, z), new THREE.Vector3(x + 1, y + 1, z + 1) ); if (playerBox.intersectsBox(blockBox)) { return true; } } } } } return false; }


        // --- Block Interaction & Outline Update ---
        function updateBlockHighlight() {
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const chunkMeshes = Object.values(world)
                                     .map(chunk => chunk.mesh)
                                     .filter(mesh => mesh !== null && mesh.parent === scene);

            if (chunkMeshes.length === 0) {
                outlineMesh.visible = false;
                return;
            }

            const intersects = raycaster.intersectObjects(chunkMeshes);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                if (intersection.distance <= BLOCK_PLACE_DISTANCE) {
                    const point = intersection.point;
                    const normal = intersection.face.normal;
                    // Get block coords by moving slightly INTO the block from intersection point
                    const blockPos = point.clone().addScaledVector(normal, -0.5).floor();

                     // Check if the block exists (isn't air already, and within world height)
                     if (blockPos.y >=0 && blockPos.y < CHUNK_HEIGHT && getBlock(blockPos.x, blockPos.y, blockPos.z) !== BLOCK_TYPES.AIR) {
                         outlineMesh.position.set(blockPos.x + 0.5, blockPos.y + 0.5, blockPos.z + 0.5);
                         outlineMesh.visible = true;
                         return; // Found a valid block to highlight
                     }
                }
            }

            // If no intersection, too far, or pointing at air/invalid block
            outlineMesh.visible = false;
        }


        function onMouseDown(event) {
            if (gameState !== 'PLAYING' || !controls.isLocked) return; // Only interact when playing

            // Raycast result should be available from updateBlockHighlight,
            // but re-casting ensures consistency if update rate differs.
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const chunkMeshes = Object.values(world)
                                     .map(chunk => chunk.mesh)
                                     .filter(mesh => mesh !== null && mesh.parent === scene);
            if (chunkMeshes.length === 0) return;

            const intersects = raycaster.intersectObjects(chunkMeshes);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                if (intersection.distance > BLOCK_PLACE_DISTANCE) return;

                const point = intersection.point;
                const normal = intersection.face.normal;

                if (event.button === 0) { // Left click - Break
                    const blockPos = point.clone().addScaledVector(normal, -0.5).floor();
                    if (getBlock(blockPos.x, blockPos.y, blockPos.z) !== BLOCK_TYPES.AIR && blockPos.y > 0) { // Don't break "bedrock" at y=0
                         setBlock(blockPos.x, blockPos.y, blockPos.z, BLOCK_TYPES.AIR);
                         updateBlockHighlight(); // Re-check highlight after breaking
                    }
                } else if (event.button === 2) { // Right click - Place
                    const placePos = point.clone().addScaledVector(normal, 0.5).floor();

                     // Simple check: Ensure placement is within world height
                     if (placePos.y < 0 || placePos.y >= CHUNK_HEIGHT) return;

                    const playerHeadBox = new THREE.Box3().setFromCenterAndSize(
                         camera.position, new THREE.Vector3(PLAYER_RADIUS*1.8, PLAYER_RADIUS*1.8, PLAYER_RADIUS*1.8)); // Check head area
                    const playerFeetBox = new THREE.Box3().setFromCenterAndSize(
                         camera.position.clone().setY(camera.position.y - PLAYER_HEIGHT + PLAYER_RADIUS), new THREE.Vector3(PLAYER_RADIUS*1.8, PLAYER_RADIUS*1.8, PLAYER_RADIUS*1.8)); // Check feet area


                    const placeBlockBox = new THREE.Box3(placePos, placePos.clone().addScalar(1));

                    if (!playerHeadBox.intersectsBox(placeBlockBox) &&
                        !playerFeetBox.intersectsBox(placeBlockBox) &&
                        getBlock(placePos.x, placePos.y, placePos.z) === BLOCK_TYPES.AIR)
                    {
                        setBlock(placePos.x, placePos.y, placePos.z, currentBlockType);
                        updateBlockHighlight(); // Re-check highlight after placing
                    } else {
                         // console.log("Cannot place block here");
                    }
                }
            }
        }

        // --- UI Setup ---
        function setupBlockSelector() { /* ... (identical) ... */
             const selectorDiv = document.getElementById('block-selector'); selectorDiv.innerHTML = ''; BLOCK_SELECT_ORDER.forEach((blockType, index) => { if (blockType === BLOCK_TYPES.AIR) return; const blockColorData = BLOCK_COLORS[blockType]; if (!blockColorData) return; const option = document.createElement('div'); option.classList.add('block-option'); option.style.backgroundColor = `#${new THREE.Color(blockColorData.top).getHexString()}`; option.dataset.blockType = blockType; option.title = Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === blockType); option.addEventListener('click', () => { currentBlockType = parseInt(option.dataset.blockType); updateSelectedBlockUI(); }); selectorDiv.appendChild(option); }); updateSelectedBlockUI(); }
        function updateSelectedBlockUI() { /* ... (identical) ... */
             const options = document.querySelectorAll('.block-option'); options.forEach(option => { if (parseInt(option.dataset.blockType) === currentBlockType) { option.classList.add('selected'); } else { option.classList.remove('selected'); } }); }

        // --- Sprint UI Setup (Now targets elements within settings) ---
        function setupSprintUI() {
            // Ensure elements exist before adding listener
            if (sprintSlider && sprintSpeedValueUI) {
                sprintSlider.addEventListener('input', (event) => {
                    sprintMultiplier = parseFloat(event.target.value);
                    sprintSpeedValueUI.textContent = `${sprintMultiplier.toFixed(1)}x`;
                });
                // Set initial value display
                sprintSpeedValueUI.textContent = `${parseFloat(sprintSlider.value).toFixed(1)}x`;
            } else {
                console.error("Sprint UI elements not found in settings!");
            }
        }

        // --- Sprint Effects ---
        function createWindLines() {
            const lineCount = 50; // Number of "wind" lines
            const positions = new Float32Array(lineCount * 2 * 3); // 2 points per line, 3 coords per point
            const colors = new Float32Array(lineCount * 2 * 3); // Color for each point

            for (let i = 0; i < lineCount; i++) {
                // Initialize lines off-screen or at center initially
                positions[i * 6 + 0] = 0; // x1
                positions[i * 6 + 1] = 0; // y1
                positions[i * 6 + 2] = 0; // z1
                positions[i * 6 + 3] = 0; // x2
                positions[i * 6 + 4] = 0; // y2
                positions[i * 6 + 5] = 0; // z2

                const alpha = Math.random() * 0.5 + 0.2; // Random transparency
                colors[i * 6 + 0] = 1; colors[i * 6 + 1] = 1; colors[i * 6 + 2] = 1; // White start
                colors[i * 6 + 3] = 1; colors[i * 6 + 4] = 1; colors[i * 6 + 5] = 1; // White end
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); // If using vertex colors

            const material = new THREE.LineBasicMaterial({
                // color: 0xffffff, // Use white if not using vertex colors
                vertexColors: true, // Use colors defined in geometry
                transparent: true,
                opacity: 0.6, // Overall max opacity
                depthTest: false, // Render on top
                linewidth: 1 // May not work on all platforms
            });

            windLinesMesh = new THREE.LineSegments(geometry, material);
            windLinesMesh.frustumCulled = false; // Ensure it's always rendered
            windLinesMesh.visible = false; // Start hidden
            camera.add(windLinesMesh); // Add to camera so it stays in front of player view
        }

        function updateWindLines(deltaTime) {
            if (!windLinesMesh || !isSprinting) {
                 if(windLinesMesh) windLinesMesh.visible = false;
                 return;
            }
             if(!windLinesMesh.visible) windLinesMesh.visible = true;


            const positions = windLinesMesh.geometry.attributes.position.array;
            const lineCount = positions.length / 6;
            const speedFactor = (sprintMultiplier / 1.8); // Scale effect with speed relative to default sprint
            const lineLength = 0.5 * speedFactor;
            const spread = 2.5; // How far lines spread out from center

            for (let i = 0; i < lineCount; i++) {
                // Check if line needs reset (moves too far back or just starting)
                 // Simple check: if z position is positive (behind start point), reset
                if (positions[i * 6 + 5] > 0 || positions[i * 6 + 2] > 0) {
                    // Reset line start point (x1, y1, z1)
                    const angle = Math.random() * Math.PI * 2;
                    const radius = (Math.random() * 0.5 + 0.8) * spread; // Start further out
                    positions[i * 6 + 0] = Math.cos(angle) * radius; // x1
                    positions[i * 6 + 1] = Math.sin(angle) * radius; // y1
                    positions[i * 6 + 2] = -Math.random() * 5 - 2;   // z1 (start in front)
                }

                // Move line end point (z2) towards camera based on speed
                const moveSpeed = (15 + Math.random() * 10) * speedFactor * deltaTime;
                positions[i * 6 + 2] += moveSpeed; // Move z1
                positions[i * 6 + 5] = positions[i * 6 + 2] + lineLength * (1 + Math.random() * 0.5); // z2 follows z1

                // Keep x/y the same for start and end for a streak effect towards center
                positions[i * 6 + 3] = positions[i * 6 + 0] * 0.95; // x2 slightly towards center
                positions[i * 6 + 4] = positions[i * 6 + 1] * 0.95; // y2 slightly towards center

            }

            windLinesMesh.geometry.attributes.position.needsUpdate = true;
        }

        // --- Particle Effects ---

        function createParticleSystem(count, position, color, type) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3);
            const lifetimes = new Float32Array(count);
            const initialLifetimes = new Float32Array(count); // Store initial lifetime for fading

            for (let i = 0; i < count; i++) {
                positions[i * 3 + 0] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;

                let vx, vy, vz;
                const life = Math.random() * 0.6 + 0.4; // Lifetime 0.4s to 1.0s

                if (type === 'jump') {
                    // Upward and outward burst
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 4 + 2;
                    vx = Math.cos(angle) * speed * (Math.random() * 0.5 + 0.5);
                    vy = Math.random() * 5 + 4; // Strong upward component
                    vz = Math.sin(angle) * speed * (Math.random() * 0.5 + 0.5);
                } else { // 'landing'
                    // Outward and slightly upward puff
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    vx = Math.cos(angle) * speed;
                    vy = Math.random() * 1.5 + 0.5; // Less upward
                    vz = Math.sin(angle) * speed;
                }

                velocities[i * 3 + 0] = vx;
                velocities[i * 3 + 1] = vy;
                velocities[i * 3 + 2] = vz;

                lifetimes[i] = life;
                initialLifetimes[i] = life;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            geometry.setAttribute('initialLifetime', new THREE.BufferAttribute(initialLifetimes, 1));


            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.15,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true, // Points get smaller further away
                depthWrite: false, // Don't obscure things behind them as much
                blending: THREE.AdditiveBlending // Brighter where particles overlap
            });

            const points = new THREE.Points(geometry, material);
            points.userData = { type: type, startTime: clock.elapsedTime }; // Store type and start time if needed
            scene.add(points);
            activeParticles.push(points);
        }

        function createJumpParticles(position) {
            // console.log("Creating jump particles at", position);
            createParticleSystem(80, position, 0xffffaa, 'jump'); // Yellowish burst
        }

        function createLandingParticles(position) {
            // console.log("Creating landing particles at", position);
            createParticleSystem(100, position, 0xaaaaaa, 'landing'); // Greyish dust puff
        }

        function updateParticles(deltaTime) {
            const gravity = new THREE.Vector3(0, GRAVITY * 0.8, 0); // Particles affected by gravity, maybe less?

            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const points = activeParticles[i];
                const geometry = points.geometry;
                const positions = geometry.attributes.position.array;
                const velocities = geometry.attributes.velocity.array;
                const lifetimes = geometry.attributes.lifetime.array;
                const initialLifetimes = geometry.attributes.initialLifetime.array;
                let aliveCount = 0;

                for (let j = 0; j < lifetimes.length; j++) {
                    lifetimes[j] -= deltaTime;

                    if (lifetimes[j] > 0) {
                        // Apply gravity to velocity
                        velocities[j * 3 + 1] += gravity.y * deltaTime;

                        // Update position
                        positions[j * 3 + 0] += velocities[j * 3 + 0] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;

                        // Simple ground collision for landing particles
                        if (points.userData.type === 'landing' && positions[j * 3 + 1] < 0) {
                             positions[j * 3 + 1] = 0; // Stop at y=0
                             velocities[j * 3 + 1] *= -0.3; // Bounce slightly
                             velocities[j * 3 + 0] *= 0.8; // Friction
                             velocities[j * 3 + 2] *= 0.8;
                        }


                        aliveCount++;
                    } else {
                        // Hide dead particles (move them far away or set scale to 0 if possible)
                        // For simplicity, we'll just let them fade out via opacity update later
                        // Or, could rebuild the buffer attribute, but that's more complex.
                    }
                }

                // Update opacity based on remaining lifetime
                const lifeRatio = lifetimes[0] / initialLifetimes[0]; // Use first particle's ratio as approximation
                points.material.opacity = Math.max(0, Math.min(1, lifeRatio * 1.5)); // Fade out


                if (aliveCount === 0 || lifetimes[0] <= 0) { // Check first particle's lifetime as proxy
                    // Remove system if all particles are dead
                    scene.remove(points);
                    geometry.dispose();
                    points.material.dispose();
                    activeParticles.splice(i, 1);
                    // console.log("Removed particle system");
                } else {
                    // Mark attributes for update
                    geometry.attributes.position.needsUpdate = true;
                    geometry.attributes.velocity.needsUpdate = true; // If velocity changes
                    geometry.attributes.lifetime.needsUpdate = true;
                }
            }
        }

        // --- Window Resize ---
        function onWindowResize() { /* ... (identical) ... */
             camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.05); // Clamp delta time
            const elapsedTime = clock.getElapsedTime(); // Get total time for smooth animations

            // Only update chunks if playing or in the initial menu
            if (gameState === 'PLAYING' || gameState === 'MENU') {
                updateWorldChunks();
            }

            // Only update particles if playing
            if (gameState === 'PLAYING') {
                updateParticles(deltaTime); // Update particles every frame
            }


            if (gameState === 'PLAYING') {
                 updatePlayer(deltaTime);
                 updateBlockHighlight(); // Update highlight every frame when playing
                 outlineMesh.visible = controls.isLocked && outlineMesh.visible; // Ensure outline hides if somehow visible when unlocked
                 if (windLinesMesh) windLinesMesh.visible = isSprinting; // Ensure wind lines match sprint state
                 // Super jump prompt visibility is handled within updatePlayer

            } else if (gameState === 'MENU' && menuCameraAnimation.active) {
                 // --- Menu Camera Animation (Only runs in MENU state) ---
                 const animSpeed = 0.05;
                 const radius = CHUNK_SIZE * 1.5;
                 const height = CHUNK_HEIGHT * 0.8; // Lower viewpoint
                 const lookRadius = CHUNK_SIZE * 0.5;

                 // Circular motion for camera position
                 camera.position.x = Math.sin(elapsedTime * animSpeed) * radius + CHUNK_SIZE / 2;
                 camera.position.z = Math.cos(elapsedTime * animSpeed) * radius + CHUNK_SIZE / 2;
                 camera.position.y = height + Math.sin(elapsedTime * animSpeed * 0.7) * 10; // Gentle bobbing

                 // Slowly moving lookAt target
                 const lookX = Math.sin(-elapsedTime * animSpeed * 0.3) * lookRadius + CHUNK_SIZE / 2;
                 const lookZ = Math.cos(-elapsedTime * animSpeed * 0.3) * lookRadius + CHUNK_SIZE / 2;
                 menuCameraAnimation.lookAtTarget.set(lookX, CHUNK_HEIGHT / 3, lookZ); // Look towards mid-height
                 camera.lookAt(menuCameraAnimation.lookAtTarget);

                 // Ensure player-specific things are off
                 outlineMesh.visible = false;
                 if (windLinesMesh) windLinesMesh.visible = false;
                 // superJumpPromptUI visibility handled by opacity/visibility now
                 // superJumpPromptUI.style.opacity = '0';
                 // superJumpPromptUI.style.visibility = 'hidden';

            } else if (gameState === 'PAUSED') {
                 // --- Paused State ---
                 // Game logic is frozen. Player, particles, chunks are not updated.
                 // Menu overlay is visible over the frozen scene.
                 outlineMesh.visible = false; // Ensure outline is hidden
                 if (windLinesMesh) windLinesMesh.visible = false; // Ensure effects are hidden
                 // superJumpPromptUI visibility handled by opacity/visibility now
                 // superJumpPromptUI.style.opacity = '0';
                 // superJumpPromptUI.style.visibility = 'hidden';
                 // No camera movement.

            } else {
                 // Fallback/idle state if needed (shouldn't really happen)
                 outlineMesh.visible = false;
                 if (windLinesMesh) windLinesMesh.visible = false;
                 // superJumpPromptUI visibility handled by opacity/visibility now
                 // superJumpPromptUI.style.opacity = '0';
                 // superJumpPromptUI.style.visibility = 'hidden';
            }

            // Render happens regardless of state to show menu/pause overlay or game
            renderer.render(scene, camera);
        }

        // --- Start the game ---
        init();

    </script>
</body>
</html>
    
  </body>
  
</html>
